{"ast":null,"code":"/**\r\n * Enum representing each log level.\r\n */\nvar LogLevel;\n\n(function (LogLevel) {\n  LogLevel[LogLevel[\"VERBOSE\"] = 10] = \"VERBOSE\";\n  LogLevel[LogLevel[\"DEBUG\"] = 20] = \"DEBUG\";\n  LogLevel[LogLevel[\"INFO\"] = 30] = \"INFO\";\n  LogLevel[LogLevel[\"WARNING\"] = 40] = \"WARNING\";\n  LogLevel[LogLevel[\"ERROR\"] = 50] = \"ERROR\";\n  LogLevel[LogLevel[\"CRITICAL\"] = 60] = \"CRITICAL\";\n})(LogLevel || (LogLevel = {}));\n/**\r\n * Get the name for a given LogLevel.\r\n * @param level LogLevel enum entry\r\n * @returns Name of the given level\r\n * @hidden\r\n */\n\n\nfunction getLogLevelName(level) {\n  switch (level) {\n    case LogLevel.VERBOSE:\n      return \"VERBOSE\";\n\n    case LogLevel.DEBUG:\n      return \"DEBUG\";\n\n    case LogLevel.INFO:\n      return \"INFO\";\n\n    case LogLevel.WARNING:\n      return \"WARNING\";\n\n    case LogLevel.ERROR:\n      return \"ERROR\";\n\n    case LogLevel.CRITICAL:\n      return \"CRITICAL\";\n\n    default:\n      throw new TypeError(\"Unknown LogLevel provided. Please use the enum LogLevel for valid levels.\");\n  }\n}\n/**\r\n * BaseHandler that takes care of filtering log records that does not meet the\r\n * required level.\r\n * Custom handler can extend this class and override the log method with their\r\n * implementation.\r\n */\n\n\nclass BaseHandler {\n  constructor(level) {\n    this.level = level;\n  }\n\n  handle(record) {\n    if (Array.isArray(this.level) && !this.level.includes(record.level)) return;\n    if (this.level > record.level) return;\n    this.log(record);\n  }\n\n}\n/**\r\n * Implements `ILogRecord`. Should be used to construct new records.\r\n * @hidden\r\n */\n\n\nclass LogRecord {\n  constructor(args, config) {\n    this.level = config.level;\n    this.levelName = getLogLevelName(config.level);\n    this.context = config.context;\n    this.args = args;\n    this.message = argsToString(args);\n    this.date = new Date();\n    this.metadata = config.metadata;\n  }\n\n}\n/**@hidden */\n\n\nfunction argsToString(args) {\n  return args.reduce((prev, curr) => prev === \"\" ? asString(curr) : `${prev} ${asString(curr)}`, \"\");\n}\n/**@hidden */\n\n\nfunction asString(data) {\n  var _a;\n\n  if (typeof data === \"string\") {\n    return data;\n  }\n\n  if (data === null || typeof data === \"number\" || typeof data === \"bigint\" || typeof data === \"boolean\" || typeof data === \"symbol\") {\n    return String(data);\n  }\n\n  if (data instanceof Error) {\n    return (_a = data.stack) !== null && _a !== void 0 ? _a : data.message;\n  }\n\n  if (typeof data === \"object\") {\n    return JSON.stringify(data);\n  }\n\n  if (typeof data === \"function\") {\n    const funcName = data.name !== \"\" ? data.name : \"(anonymous)\";\n    return `[Function ${funcName}]`;\n  }\n\n  return \"undefined\";\n}\n\nclass Logger {\n  /**\r\n   * Creates a new logger with no handlers configured. Add handlers with `addHandler`\r\n   * using a Fluent API.\r\n   * @param context Context for the new logger. Defaults to `Default`.\r\n   */\n  constructor(context) {\n    this._metadata = {};\n    this.handlers = [];\n    this._context = context !== null && context !== void 0 ? context : \"Default\";\n  }\n\n  get context() {\n    return this._context;\n  }\n\n  get metadata() {\n    return this._metadata;\n  }\n\n  withContext(context) {\n    return new Logger(context).addHandlers(this.handlers).addMetadata(this.metadata);\n  }\n\n  addMetadata(metadata) {\n    this._metadata = Object.assign(Object.assign({}, this._metadata), metadata);\n    return this;\n  }\n\n  addHandlers(handlers) {\n    for (const handler of handlers) {\n      this.handlers.push(handler);\n    }\n\n    return this;\n  }\n\n  addHandler(handler, condition) {\n    if (typeof condition === \"boolean\" && !condition) return this;\n    if (typeof condition === \"function\" && !condition()) return this;\n    this.handlers.push(handler);\n    return this;\n  }\n\n  notifyHandlers(level, args) {\n    const record = new LogRecord(args, {\n      level,\n      context: this._context,\n      metadata: this._metadata\n    });\n\n    for (const handler of this.handlers) {\n      handler.handle(record);\n    }\n  }\n\n  verbose() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    this.notifyHandlers(LogLevel.VERBOSE, args);\n  }\n\n  debug() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    this.notifyHandlers(LogLevel.DEBUG, args);\n  }\n\n  info() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    this.notifyHandlers(LogLevel.INFO, args);\n  }\n\n  warning() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    this.notifyHandlers(LogLevel.WARNING, args);\n  }\n\n  error() {\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    this.notifyHandlers(LogLevel.ERROR, args);\n  }\n\n  critical() {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    this.notifyHandlers(LogLevel.CRITICAL, args);\n  }\n\n}\n/**\r\n * Helper to statically store loggers globally.\r\n */\n\n\nclass LoggerStore {\n  /** Returns a logger if it exists for the give key. */\n  static get(key) {\n    return this.store.get(key);\n  }\n  /** Add a logger to the given key or overrides it. */\n\n\n  static add(key, logger) {\n    this.store.set(key, logger);\n  }\n  /**\r\n   * Removes a logger for a given key.\r\n   * @returns True if a logger was removed. False otherwise.\r\n   */\n\n\n  static remove(key) {\n    return this.store.delete(key);\n  }\n\n}\n\nLoggerStore.store = new Map();\n/**\r\n * Writes logs to the console with the native `console` object. Log format:\r\n * ISO-time-string [context] message\r\n */\n\nclass ConsoleHandler extends BaseHandler {\n  constructor(level, options) {\n    var _a;\n\n    super(level);\n    this.format = (_a = options === null || options === void 0 ? void 0 : options.format) !== null && _a !== void 0 ? _a : this.defaultFormat;\n  }\n\n  static toggle(active) {\n    ConsoleHandler.active = active !== null && active !== void 0 ? active : !ConsoleHandler.active;\n    return ConsoleHandler.active;\n  }\n\n  log(record) {\n    if (!ConsoleHandler.active) return;\n\n    switch (record.level) {\n      case LogLevel.VERBOSE:\n        console.debug(this.format(record));\n        break;\n\n      case LogLevel.DEBUG:\n        console.debug(this.format(record));\n        break;\n\n      case LogLevel.INFO:\n        console.info(this.format(record));\n        break;\n\n      case LogLevel.WARNING:\n        console.warn(this.format(record));\n        break;\n\n      case LogLevel.ERROR:\n        console.error(this.format(record));\n        break;\n\n      case LogLevel.CRITICAL:\n        console.error(this.format(record));\n        break;\n    }\n  }\n\n  defaultFormat(record) {\n    return `${record.levelName}: [${record.context}] - ${record.message}`;\n  }\n\n}\n\nConsoleHandler.active = true;\n/**\r\n * Logging handler that is intended to be used in tests. During testing logs should\r\n * not flood the console.\r\n */\n\nclass TestHandler extends BaseHandler {\n  /**\r\n   * @param level Defaults to `VERBOSE`.\r\n   */\n  constructor() {\n    let level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LogLevel.VERBOSE;\n    super(level);\n    /** Queue with all log records handled by this handler. */\n\n    this.records = [];\n  }\n\n  log(record) {\n    this.records.push(record);\n  }\n\n}\n\nexport { BaseHandler, ConsoleHandler, LogLevel, Logger, LoggerStore, TestHandler };","map":{"version":3,"mappings":"","names":[],"sources":[],"sourcesContent":["/**\r\n * Enum representing each log level.\r\n */\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"VERBOSE\"] = 10] = \"VERBOSE\";\r\n    LogLevel[LogLevel[\"DEBUG\"] = 20] = \"DEBUG\";\r\n    LogLevel[LogLevel[\"INFO\"] = 30] = \"INFO\";\r\n    LogLevel[LogLevel[\"WARNING\"] = 40] = \"WARNING\";\r\n    LogLevel[LogLevel[\"ERROR\"] = 50] = \"ERROR\";\r\n    LogLevel[LogLevel[\"CRITICAL\"] = 60] = \"CRITICAL\";\r\n})(LogLevel || (LogLevel = {}));\r\n/**\r\n * Get the name for a given LogLevel.\r\n * @param level LogLevel enum entry\r\n * @returns Name of the given level\r\n * @hidden\r\n */\r\nfunction getLogLevelName(level) {\r\n    switch (level) {\r\n        case LogLevel.VERBOSE:\r\n            return \"VERBOSE\";\r\n        case LogLevel.DEBUG:\r\n            return \"DEBUG\";\r\n        case LogLevel.INFO:\r\n            return \"INFO\";\r\n        case LogLevel.WARNING:\r\n            return \"WARNING\";\r\n        case LogLevel.ERROR:\r\n            return \"ERROR\";\r\n        case LogLevel.CRITICAL:\r\n            return \"CRITICAL\";\r\n        default:\r\n            throw new TypeError(\"Unknown LogLevel provided. Please use the enum LogLevel for valid levels.\");\r\n    }\r\n}\n\n/**\r\n * BaseHandler that takes care of filtering log records that does not meet the\r\n * required level.\r\n * Custom handler can extend this class and override the log method with their\r\n * implementation.\r\n */\r\nclass BaseHandler {\r\n    constructor(level) {\r\n        this.level = level;\r\n    }\r\n    handle(record) {\r\n        if (Array.isArray(this.level) && !this.level.includes(record.level))\r\n            return;\r\n        if (this.level > record.level)\r\n            return;\r\n        this.log(record);\r\n    }\r\n}\n\n/**\r\n * Implements `ILogRecord`. Should be used to construct new records.\r\n * @hidden\r\n */\r\nclass LogRecord {\r\n    constructor(args, config) {\r\n        this.level = config.level;\r\n        this.levelName = getLogLevelName(config.level);\r\n        this.context = config.context;\r\n        this.args = args;\r\n        this.message = argsToString(args);\r\n        this.date = new Date();\r\n        this.metadata = config.metadata;\r\n    }\r\n}\r\n/**@hidden */\r\nfunction argsToString(args) {\r\n    return args.reduce((prev, curr) => prev === \"\" ? asString(curr) : `${prev} ${asString(curr)}`, \"\");\r\n}\r\n/**@hidden */\r\nfunction asString(data) {\r\n    var _a;\r\n    if (typeof data === \"string\") {\r\n        return data;\r\n    }\r\n    if (data === null ||\r\n        typeof data === \"number\" ||\r\n        typeof data === \"bigint\" ||\r\n        typeof data === \"boolean\" ||\r\n        typeof data === \"symbol\") {\r\n        return String(data);\r\n    }\r\n    if (data instanceof Error) {\r\n        return (_a = data.stack) !== null && _a !== void 0 ? _a : data.message;\r\n    }\r\n    if (typeof data === \"object\") {\r\n        return JSON.stringify(data);\r\n    }\r\n    if (typeof data === \"function\") {\r\n        const funcName = data.name !== \"\" ? data.name : \"(anonymous)\";\r\n        return `[Function ${funcName}]`;\r\n    }\r\n    return \"undefined\";\r\n}\n\nclass Logger {\r\n    /**\r\n     * Creates a new logger with no handlers configured. Add handlers with `addHandler`\r\n     * using a Fluent API.\r\n     * @param context Context for the new logger. Defaults to `Default`.\r\n     */\r\n    constructor(context) {\r\n        this._metadata = {};\r\n        this.handlers = [];\r\n        this._context = context !== null && context !== void 0 ? context : \"Default\";\r\n    }\r\n    get context() {\r\n        return this._context;\r\n    }\r\n    get metadata() {\r\n        return this._metadata;\r\n    }\r\n    withContext(context) {\r\n        return new Logger(context)\r\n            .addHandlers(this.handlers)\r\n            .addMetadata(this.metadata);\r\n    }\r\n    addMetadata(metadata) {\r\n        this._metadata = Object.assign(Object.assign({}, this._metadata), metadata);\r\n        return this;\r\n    }\r\n    addHandlers(handlers) {\r\n        for (const handler of handlers) {\r\n            this.handlers.push(handler);\r\n        }\r\n        return this;\r\n    }\r\n    addHandler(handler, condition) {\r\n        if (typeof condition === \"boolean\" && !condition)\r\n            return this;\r\n        if (typeof condition === \"function\" && !condition())\r\n            return this;\r\n        this.handlers.push(handler);\r\n        return this;\r\n    }\r\n    notifyHandlers(level, args) {\r\n        const record = new LogRecord(args, {\r\n            level,\r\n            context: this._context,\r\n            metadata: this._metadata,\r\n        });\r\n        for (const handler of this.handlers) {\r\n            handler.handle(record);\r\n        }\r\n    }\r\n    verbose(...args) {\r\n        this.notifyHandlers(LogLevel.VERBOSE, args);\r\n    }\r\n    debug(...args) {\r\n        this.notifyHandlers(LogLevel.DEBUG, args);\r\n    }\r\n    info(...args) {\r\n        this.notifyHandlers(LogLevel.INFO, args);\r\n    }\r\n    warning(...args) {\r\n        this.notifyHandlers(LogLevel.WARNING, args);\r\n    }\r\n    error(...args) {\r\n        this.notifyHandlers(LogLevel.ERROR, args);\r\n    }\r\n    critical(...args) {\r\n        this.notifyHandlers(LogLevel.CRITICAL, args);\r\n    }\r\n}\n\n/**\r\n * Helper to statically store loggers globally.\r\n */\r\nclass LoggerStore {\r\n    /** Returns a logger if it exists for the give key. */\r\n    static get(key) {\r\n        return this.store.get(key);\r\n    }\r\n    /** Add a logger to the given key or overrides it. */\r\n    static add(key, logger) {\r\n        this.store.set(key, logger);\r\n    }\r\n    /**\r\n     * Removes a logger for a given key.\r\n     * @returns True if a logger was removed. False otherwise.\r\n     */\r\n    static remove(key) {\r\n        return this.store.delete(key);\r\n    }\r\n}\r\nLoggerStore.store = new Map();\n\n/**\r\n * Writes logs to the console with the native `console` object. Log format:\r\n * ISO-time-string [context] message\r\n */\r\nclass ConsoleHandler extends BaseHandler {\r\n    constructor(level, options) {\r\n        var _a;\r\n        super(level);\r\n        this.format = (_a = options === null || options === void 0 ? void 0 : options.format) !== null && _a !== void 0 ? _a : this.defaultFormat;\r\n    }\r\n    static toggle(active) {\r\n        ConsoleHandler.active = active !== null && active !== void 0 ? active : !ConsoleHandler.active;\r\n        return ConsoleHandler.active;\r\n    }\r\n    log(record) {\r\n        if (!ConsoleHandler.active)\r\n            return;\r\n        switch (record.level) {\r\n            case LogLevel.VERBOSE:\r\n                console.debug(this.format(record));\r\n                break;\r\n            case LogLevel.DEBUG:\r\n                console.debug(this.format(record));\r\n                break;\r\n            case LogLevel.INFO:\r\n                console.info(this.format(record));\r\n                break;\r\n            case LogLevel.WARNING:\r\n                console.warn(this.format(record));\r\n                break;\r\n            case LogLevel.ERROR:\r\n                console.error(this.format(record));\r\n                break;\r\n            case LogLevel.CRITICAL:\r\n                console.error(this.format(record));\r\n                break;\r\n        }\r\n    }\r\n    defaultFormat(record) {\r\n        return `${record.levelName}: [${record.context}] - ${record.message}`;\r\n    }\r\n}\r\nConsoleHandler.active = true;\n\n/**\r\n * Logging handler that is intended to be used in tests. During testing logs should\r\n * not flood the console.\r\n */\r\nclass TestHandler extends BaseHandler {\r\n    /**\r\n     * @param level Defaults to `VERBOSE`.\r\n     */\r\n    constructor(level = LogLevel.VERBOSE) {\r\n        super(level);\r\n        /** Queue with all log records handled by this handler. */\r\n        this.records = [];\r\n    }\r\n    log(record) {\r\n        this.records.push(record);\r\n    }\r\n}\n\nexport { BaseHandler, ConsoleHandler, LogLevel, Logger, LoggerStore, TestHandler };\n"]},"metadata":{},"sourceType":"module"}