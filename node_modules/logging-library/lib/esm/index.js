/**
 * Enum representing each log level.
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["VERBOSE"] = 10] = "VERBOSE";
    LogLevel[LogLevel["DEBUG"] = 20] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 30] = "INFO";
    LogLevel[LogLevel["WARNING"] = 40] = "WARNING";
    LogLevel[LogLevel["ERROR"] = 50] = "ERROR";
    LogLevel[LogLevel["CRITICAL"] = 60] = "CRITICAL";
})(LogLevel || (LogLevel = {}));
/**
 * Get the name for a given LogLevel.
 * @param level LogLevel enum entry
 * @returns Name of the given level
 * @hidden
 */
function getLogLevelName(level) {
    switch (level) {
        case LogLevel.VERBOSE:
            return "VERBOSE";
        case LogLevel.DEBUG:
            return "DEBUG";
        case LogLevel.INFO:
            return "INFO";
        case LogLevel.WARNING:
            return "WARNING";
        case LogLevel.ERROR:
            return "ERROR";
        case LogLevel.CRITICAL:
            return "CRITICAL";
        default:
            throw new TypeError("Unknown LogLevel provided. Please use the enum LogLevel for valid levels.");
    }
}

/**
 * BaseHandler that takes care of filtering log records that does not meet the
 * required level.
 * Custom handler can extend this class and override the log method with their
 * implementation.
 */
class BaseHandler {
    constructor(level) {
        this.level = level;
    }
    handle(record) {
        if (Array.isArray(this.level) && !this.level.includes(record.level))
            return;
        if (this.level > record.level)
            return;
        this.log(record);
    }
}

/**
 * Implements `ILogRecord`. Should be used to construct new records.
 * @hidden
 */
class LogRecord {
    constructor(args, config) {
        this.level = config.level;
        this.levelName = getLogLevelName(config.level);
        this.context = config.context;
        this.args = args;
        this.message = argsToString(args);
        this.date = new Date();
        this.metadata = config.metadata;
    }
}
/**@hidden */
function argsToString(args) {
    return args.reduce((prev, curr) => prev === "" ? asString(curr) : `${prev} ${asString(curr)}`, "");
}
/**@hidden */
function asString(data) {
    var _a;
    if (typeof data === "string") {
        return data;
    }
    if (data === null ||
        typeof data === "number" ||
        typeof data === "bigint" ||
        typeof data === "boolean" ||
        typeof data === "symbol") {
        return String(data);
    }
    if (data instanceof Error) {
        return (_a = data.stack) !== null && _a !== void 0 ? _a : data.message;
    }
    if (typeof data === "object") {
        return JSON.stringify(data);
    }
    if (typeof data === "function") {
        const funcName = data.name !== "" ? data.name : "(anonymous)";
        return `[Function ${funcName}]`;
    }
    return "undefined";
}

class Logger {
    /**
     * Creates a new logger with no handlers configured. Add handlers with `addHandler`
     * using a Fluent API.
     * @param context Context for the new logger. Defaults to `Default`.
     */
    constructor(context) {
        this._metadata = {};
        this.handlers = [];
        this._context = context !== null && context !== void 0 ? context : "Default";
    }
    get context() {
        return this._context;
    }
    get metadata() {
        return this._metadata;
    }
    withContext(context) {
        return new Logger(context)
            .addHandlers(this.handlers)
            .addMetadata(this.metadata);
    }
    addMetadata(metadata) {
        this._metadata = Object.assign(Object.assign({}, this._metadata), metadata);
        return this;
    }
    addHandlers(handlers) {
        for (const handler of handlers) {
            this.handlers.push(handler);
        }
        return this;
    }
    addHandler(handler, condition) {
        if (typeof condition === "boolean" && !condition)
            return this;
        if (typeof condition === "function" && !condition())
            return this;
        this.handlers.push(handler);
        return this;
    }
    notifyHandlers(level, args) {
        const record = new LogRecord(args, {
            level,
            context: this._context,
            metadata: this._metadata,
        });
        for (const handler of this.handlers) {
            handler.handle(record);
        }
    }
    verbose(...args) {
        this.notifyHandlers(LogLevel.VERBOSE, args);
    }
    debug(...args) {
        this.notifyHandlers(LogLevel.DEBUG, args);
    }
    info(...args) {
        this.notifyHandlers(LogLevel.INFO, args);
    }
    warning(...args) {
        this.notifyHandlers(LogLevel.WARNING, args);
    }
    error(...args) {
        this.notifyHandlers(LogLevel.ERROR, args);
    }
    critical(...args) {
        this.notifyHandlers(LogLevel.CRITICAL, args);
    }
}

/**
 * Helper to statically store loggers globally.
 */
class LoggerStore {
    /** Returns a logger if it exists for the give key. */
    static get(key) {
        return this.store.get(key);
    }
    /** Add a logger to the given key or overrides it. */
    static add(key, logger) {
        this.store.set(key, logger);
    }
    /**
     * Removes a logger for a given key.
     * @returns True if a logger was removed. False otherwise.
     */
    static remove(key) {
        return this.store.delete(key);
    }
}
LoggerStore.store = new Map();

/**
 * Writes logs to the console with the native `console` object. Log format:
 * ISO-time-string [context] message
 */
class ConsoleHandler extends BaseHandler {
    constructor(level, options) {
        var _a;
        super(level);
        this.format = (_a = options === null || options === void 0 ? void 0 : options.format) !== null && _a !== void 0 ? _a : this.defaultFormat;
    }
    static toggle(active) {
        ConsoleHandler.active = active !== null && active !== void 0 ? active : !ConsoleHandler.active;
        return ConsoleHandler.active;
    }
    log(record) {
        if (!ConsoleHandler.active)
            return;
        switch (record.level) {
            case LogLevel.VERBOSE:
                console.debug(this.format(record));
                break;
            case LogLevel.DEBUG:
                console.debug(this.format(record));
                break;
            case LogLevel.INFO:
                console.info(this.format(record));
                break;
            case LogLevel.WARNING:
                console.warn(this.format(record));
                break;
            case LogLevel.ERROR:
                console.error(this.format(record));
                break;
            case LogLevel.CRITICAL:
                console.error(this.format(record));
                break;
        }
    }
    defaultFormat(record) {
        return `${record.levelName}: [${record.context}] - ${record.message}`;
    }
}
ConsoleHandler.active = true;

/**
 * Logging handler that is intended to be used in tests. During testing logs should
 * not flood the console.
 */
class TestHandler extends BaseHandler {
    /**
     * @param level Defaults to `VERBOSE`.
     */
    constructor(level = LogLevel.VERBOSE) {
        super(level);
        /** Queue with all log records handled by this handler. */
        this.records = [];
    }
    log(record) {
        this.records.push(record);
    }
}

export { BaseHandler, ConsoleHandler, LogLevel, Logger, LoggerStore, TestHandler };
//# sourceMappingURL=index.js.map
